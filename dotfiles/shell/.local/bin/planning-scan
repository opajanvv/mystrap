#!/usr/bin/env python3
"""
planning-scan - Scan planning workspace and output structured JSON

Usage: planning-scan

Scans tasks, projects, and ideas folders and outputs JSON for use by
Claude Code commands like /refresh-planning and /process-inbox.
"""

import json
import os
import random
import re
import sys
from datetime import datetime, timedelta
from pathlib import Path

import yaml


def get_vault_dir():
    return Path(os.environ.get("OBSIDIAN_VAULT", os.path.expanduser("~/Cloud/janvv/life/planning")))


def parse_frontmatter(content):
    """Extract YAML frontmatter from markdown file."""
    if not content.startswith("---"):
        return {}

    end = content.find("---", 3)
    if end == -1:
        return {}

    try:
        return yaml.safe_load(content[3:end]) or {}
    except yaml.YAMLError:
        return {}


def get_unchecked_items(content):
    """Extract unchecked checkbox items from markdown."""
    items = []
    for line in content.split("\n"):
        match = re.match(r"^\s*-\s*\[\s*\]\s*(.+)$", line)
        if match:
            items.append(match.group(1).strip())
    return items


def scan_inbox(vault_dir):
    """Scan tasks/inbox/ for items."""
    inbox_dir = vault_dir / "tasks" / "inbox"
    items = []

    if not inbox_dir.exists():
        return {"count": 0, "items": []}

    for f in inbox_dir.iterdir():
        if not f.is_file() or f.name == "CLAUDE.md":
            continue
        if f.suffix == ".md":
            content = f.read_text()
            fm = parse_frontmatter(content)
            if fm.get("status") in ("done", "killed"):
                continue
        items.append({
            "name": f.stem,
            "path": str(f.relative_to(vault_dir))
        })

    return {"count": len(items), "items": items}


def scan_active_tasks(vault_dir, today):
    """Scan tasks/active/ and categorize by due date."""
    active_dir = vault_dir / "tasks" / "active"

    result = {
        "count": 0,
        "overdue": [],
        "due_today": [],
        "due_soon": [],
        "no_due_date": []
    }

    if not active_dir.exists():
        return result

    soon_cutoff = today + timedelta(days=7)

    for f in active_dir.glob("*.md"):
        if f.name == "CLAUDE.md":
            continue

        content = f.read_text()
        fm = parse_frontmatter(content)

        if fm.get("status") in ("done", "killed"):
            continue

        task = {
            "name": f.stem,
            "path": str(f.relative_to(vault_dir)),
            "due": fm.get("due"),
            "priority": fm.get("priority"),
            "project": fm.get("project")
        }

        # Convert due date if it's a date object
        if isinstance(task["due"], datetime):
            task["due"] = task["due"].strftime("%Y-%m-%d")
        elif hasattr(task["due"], "isoformat"):
            task["due"] = task["due"].isoformat()

        result["count"] += 1

        if not task["due"]:
            result["no_due_date"].append(task)
        else:
            try:
                due_date = datetime.strptime(str(task["due"]), "%Y-%m-%d").date()
                if due_date < today:
                    result["overdue"].append(task)
                elif due_date == today:
                    result["due_today"].append(task)
                elif due_date <= soon_cutoff:
                    result["due_soon"].append(task)
                # Tasks with due dates beyond 7 days are tracked but not shown
            except ValueError:
                result["no_due_date"].append(task)

    return result


def scan_projects(vault_dir):
    """Scan projects/ for status and progress."""
    projects_dir = vault_dir / "projects"

    result = {
        "target": None,
        "active": [],
        "paused": []
    }

    if not projects_dir.exists():
        return result

    for f in projects_dir.glob("*.md"):
        if f.name == "CLAUDE.md":
            continue

        content = f.read_text()
        fm = parse_frontmatter(content)

        if fm.get("status") in ("done", "killed"):
            continue

        unchecked = get_unchecked_items(content)

        project = {
            "name": f.stem,
            "path": str(f.relative_to(vault_dir)),
            "unchecked_count": len(unchecked)
        }

        status = fm.get("status", "active")
        is_target = fm.get("target", False)

        if is_target:
            result["target"] = {
                **project,
                "unchecked_items": unchecked
            }
        elif status == "active":
            result["active"].append(project)
        elif status == "paused":
            result["paused"].append(project)

    return result


def scan_ideas(vault_dir):
    """Scan ideas/ recursively for someday items."""
    ideas_dir = vault_dir / "ideas"
    today = datetime.now().date()
    stale_cutoff = today - timedelta(days=90)

    result = {
        "someday_count": 0,
        "random_someday": None,
        "unreviewed": {
            "total": 0,
            "reviewed": 0,
            "next": None
        }
    }

    if not ideas_dir.exists():
        return result

    someday_ideas = []
    unreviewed_ideas = []

    for f in ideas_dir.rglob("*.md"):
        if f.name == "CLAUDE.md":
            continue

        content = f.read_text()
        fm = parse_frontmatter(content)

        if fm.get("status") == "someday":
            # Get category from parent folder
            category = f.parent.name if f.parent != ideas_dir else None
            created = fm.get("created")
            reviewed = fm.get("reviewed")

            # Convert date objects to strings for JSON
            if hasattr(created, "isoformat"):
                created = created.isoformat()
            if hasattr(reviewed, "isoformat"):
                reviewed = reviewed.isoformat()

            idea = {
                "name": f.stem,
                "path": str(f.relative_to(vault_dir)),
                "category": category,
                "created": str(created) if created else None
            }

            someday_ideas.append(idea)

            # Check if needs review (no reviewed date, or reviewed > 90 days ago)
            needs_review = False
            if not reviewed:
                needs_review = True
            else:
                try:
                    reviewed_date = datetime.strptime(str(reviewed), "%Y-%m-%d").date()
                    if reviewed_date < stale_cutoff:
                        needs_review = True
                except ValueError:
                    needs_review = True

            if needs_review:
                unreviewed_ideas.append(idea)

    result["someday_count"] = len(someday_ideas)

    if someday_ideas:
        result["random_someday"] = random.choice(someday_ideas)

    # Sort unreviewed by category (uncategorized last), then by created date (oldest first)
    unreviewed_ideas.sort(key=lambda x: (x["category"] or "zzz", x["created"] or ""))

    result["unreviewed"]["total"] = len(someday_ideas)
    result["unreviewed"]["reviewed"] = len(someday_ideas) - len(unreviewed_ideas)
    result["unreviewed"]["items"] = unreviewed_ideas

    return result


def scan_stale_tasks(vault_dir, today):
    """Find active tasks older than 3 weeks with no due date and no project link."""
    active_dir = vault_dir / "tasks" / "active"
    stale_cutoff = today - timedelta(days=21)
    stale = []

    if not active_dir.exists():
        return {"count": 0, "items": []}

    for f in active_dir.glob("*.md"):
        if f.name == "CLAUDE.md":
            continue

        content = f.read_text()
        fm = parse_frontmatter(content)

        if fm.get("status") in ("done", "killed"):
            continue
        if fm.get("due") or fm.get("project"):
            continue

        created = fm.get("created")
        if not created:
            continue

        try:
            if hasattr(created, "isoformat"):
                created_date = created if hasattr(created, "year") else datetime.strptime(str(created), "%Y-%m-%d").date()
            else:
                created_date = datetime.strptime(str(created), "%Y-%m-%d").date()
        except ValueError:
            continue

        # Use reviewed date if present (set when user says "keep" during triage)
        reference_date = created_date
        reviewed = fm.get("reviewed")
        if reviewed:
            try:
                if hasattr(reviewed, "isoformat"):
                    reviewed_date = reviewed if hasattr(reviewed, "year") else datetime.strptime(str(reviewed), "%Y-%m-%d").date()
                else:
                    reviewed_date = datetime.strptime(str(reviewed), "%Y-%m-%d").date()
                if reviewed_date > reference_date:
                    reference_date = reviewed_date
            except ValueError:
                pass

        if reference_date <= stale_cutoff:
            stale.append({
                "name": f.stem,
                "path": str(f.relative_to(vault_dir)),
                "priority": fm.get("priority"),
                "created": created_date.isoformat(),
                "age_days": (today - created_date).days
            })

    stale.sort(key=lambda x: x["created"])
    return {"count": len(stale), "items": stale}


def main():
    vault_dir = get_vault_dir()
    today = datetime.now().date()

    result = {
        "inbox": scan_inbox(vault_dir),
        "active_tasks": scan_active_tasks(vault_dir, today),
        "stale_tasks": scan_stale_tasks(vault_dir, today),
        "projects": scan_projects(vault_dir),
        "ideas": scan_ideas(vault_dir),
        "scan_date": today.isoformat()
    }

    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
